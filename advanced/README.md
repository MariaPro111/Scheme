# scheme-advanced

Это четвертая часть [scheme](../../scheme).

## Что сделано?

В интерпретатор добавлена поддержка `if`, переменных и лямбда-функций с захватом контекста.

### If

Работает как if. Возможны 2 формы записи.

* `(if condition true-branch)`
* `(if condition true-branch false-branch)`

Сначала вычисляет `condition` и проверяет значение на истинность. Затем вычисляет либо `true-branch`, либо `false-branch` и возвращает как результат всего `if`-а.

### Переменные

Поддержка переменных реализована с помощью особых форм `define` и `set!`.

```scheme
$ (define x 1)
> ()
$ x
> 1
```

Команда `set!` используется для изменения значения **существующей**
переменной:

```scheme
$ (define x 1)
> ()
$ (set! x 2)
$ x
> 2
$ (set! y 1)
> NameError
```

### Лямбда-функции

Синтаксис:

* `(lambda (x) (+ 1 x))`
* `(lambda (x y) (* y x))`
* `(lambda (x) (set! x (* x 2)) (+ 1 x))`
* `(lambda () 1)`

Создаёт новую функцию. Сначала перечисляется список аргументов функции, затем её тело. Тело может состоять из нескольких выражений, в этом случае они вычисляются по порядку а результат последнего выражения становится результатом функции.

Запись `(define (fn-name <args>) <body>)` эквивалентна `(define fn-name (lambda (<args>) <body>))`. То есть, запись `(define (inc x) (+ x 1))` создаёт новую функцию `inc`.

### Захват контекста

#### Lambda capture in C++

Также возможен и захват контекста. Синтаксис примерно совпадает с C++:

```c++
auto Range(int x) {
  return [&x] () {
    ++x;
    return x;
  };
}

void F() {
  auto r = Range(10);

  std::cout << r() << std::endl; // 11
  std::cout << r() << std::endl; // 12
}
```

В **Scheme**:

```scheme
$ (define range
    (lambda (x)
      (lambda ()
        (set! x (+ x 1))
        x)))

$ (define my-range (range 10))

$ (my-range)
> 11

$ (my-range)
> 12
```

Такой код на С++ содержит UB - ссылка на `x` становится висящей после выхода из `Range()`. В Scheme такого не происходит - объект должен жить, пока на него кто-либо ссылается.

